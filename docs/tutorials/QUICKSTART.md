# Руководство по быстрому старту

Этот туториал проведет вас через процесс создания простого агента, который
использует LedgerMind для отслеживания архитектурных решений и правил стиля
кода. Вы научитесь записывать, искать и обновлять знания агента.

## Предварительные требования

Перед началом работы убедитесь, что в вашей системе установлен Python 3.10 или
выше. Вы можете установить LedgerMind с помощью `pip`.

```bash
pip install ledgermind
```

## Быстрый запуск

Для локальных CLI-инструментов или автономных агентов используйте класс
`IntegrationBridge`. Это самый простой способ начать работу с системой.

```python
from ledgermind.core.api.bridge import IntegrationBridge

# Инициализируйте систему памяти
bridge = IntegrationBridge(memory_path="./project_memory")
memory = bridge.memory
```

## 1. Запись архитектурного решения

Представьте, что ваш агент анализирует кодовую базу и решает, что проект должен
использовать **FastAPI** из-за его производительности.

Вы можете зафиксировать это решение в семантической памяти следующим образом:

```python
memory.record_decision(
    title="Использовать FastAPI для веб-слоя",
    target="web_framework",
    rationale="FastAPI обеспечивает высокую производительность и автоматическую "
              "генерацию OpenAPI, что важно для наших микросервисов."
)
print("Решение записано!")
```

## 2. Поиск знаний

Позже этому же или другому агенту может понадобиться узнать, какой фреймворк
выбран для проекта. Вы можете выполнить семантический поиск по памяти.

```python
# Поиск с использованием семантического запроса
results = memory.search_decisions("Какой фреймворк мы используем для веба?")

for res in results:
    print(f"Найдено: {res['title']} (Статус: {res['status']})")
    print(f"Обоснование: {res['rationale']}")
```

## 3. Эволюция знаний и авто-замещение

Технологии меняются со временем. В LedgerMind v2.6.0 вам больше не нужно вручную
искать ID старого решения для простых обновлений. Если новое обоснование
семантически похоже на старое, система сама выполнит замещение.

```python
# Просто запишите обновленное решение для той же цели (target)
memory.record_decision(
    title="Оптимизация FastAPI: переход на Pydantic v2",
    target="web_framework",
    rationale="Обновление до Pydantic v2 даст нам прирост производительности "
              "валидации в 5-10 раз."
)
# LedgerMind обнаружит сходство с предыдущим решением по web_framework 
# и автоматически свяжет их через 'supersede'.
```

Для радикальных изменений (например, переход с Python на Go) мы рекомендуем
использовать явный вызов `supersede_decision`:

```python
# Получите ID старого решения
old_id = memory.search_decisions("FastAPI", mode="audit")[0]['id']

# Явное замещение при смене парадигмы
memory.supersede_decision(
    title="Миграция на Go (Gin) для веб-слоя",
    target="web_framework",
    rationale="Нам нужна модель конкурентности Go для высокой нагрузки.",
    old_decision_ids=[old_id]
)
```


## 4. Разрешение истины

Система автоматически приоритизирует актуальные данные. Если вы выполните поиск
сейчас, LedgerMind вернет активное решение на Go, даже если запрос содержит
упоминание «FastAPI».

Это происходит благодаря механизму рекурсивного разрешения истины:

```python
# Система знает, что решение по FastAPI было замещено
results = memory.search_decisions("веб-фреймворк FastAPI", mode="balanced")
print(f"Топ результат: {results[0]['title']} (Статус: {results[0]['status']})")
# Вывод: Топ результат: Миграция на Go (Gin) для веб-слоя (Статус: active)
```

## 5. Аудит через Git

Каждая операция, описанная выше, создает автоматический коммит в `Git`. Вы
можете проверить историю изменений в директории памяти.

Используйте стандартные команды `Git` для просмотра логов:

```bash
cd project_memory
git log --oneline
```

Это гарантирует, что любое изменение в «сознании» агента полностью прозрачно и
может быть проверено человеком.

## Следующие шаги

Вы успешно освоили базовые операции с памятью LedgerMind. Теперь вы можете
интегрировать систему в более сложные сценарии.

- [Руководство по интеграции](../INTEGRATION_GUIDE.md) — узнайте, как настроить
  MCP-сервер.
- [Архитектура](../../README.md#архитектура) — изучите внутреннее устройство
  модулей.
