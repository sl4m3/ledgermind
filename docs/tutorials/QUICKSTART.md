# Руководство по быстрому старту

Этот туториал проведет вас через процесс создания простого агента, который
использует Ledgermind для отслеживания архитектурных решений и правил стиля
кода. Вы научитесь записывать, искать и обновлять знания агента.

## Предварительные требования

Перед началом работы убедитесь, что в вашей системе установлен Python 3.10 или
выше. Вы можете установить Ledgermind с помощью `pip`.

```bash
pip install ledgermind
```

## Быстрый запуск

Для локальных CLI-инструментов или автономных агентов используйте класс
`IntegrationBridge`. Это самый простой способ начать работу с системой.

```python
from ledgermind.core.api.bridge import IntegrationBridge

# Инициализируйте систему памяти
bridge = IntegrationBridge(memory_path="./project_memory")
memory = bridge.memory
```

## 1. Запись архитектурного решения

Представьте, что ваш агент анализирует кодовую базу и решает, что проект должен
использовать **FastAPI** из-за его производительности.

Вы можете зафиксировать это решение в семантической памяти следующим образом:

```python
memory.record_decision(
    title="Использовать FastAPI для веб-слоя",
    target="web_framework",
    rationale="FastAPI обеспечивает высокую производительность и автоматическую "
              "генерацию OpenAPI, что важно для наших микросервисов."
)
print("Решение записано!")
```

## 2. Поиск знаний

Позже этому же или другому агенту может понадобиться узнать, какой фреймворк
выбран для проекта. Вы можете выполнить семантический поиск по памяти.

```python
# Поиск с использованием семантического запроса
results = memory.search_decisions("Какой фреймворк мы используем для веба?")

for res in results:
    print(f"Найдено: {res['title']} (Статус: {res['status']})")
    print(f"Обоснование: {res['rationale']}")
```

## 3. Эволюция знаний и замещение

Технологии меняются со временем. Если через год команда решит перейти на **Go
(Gin)** для еще большей производительности, вам не нужно удалять старую память.

Вместо этого вы можете использовать механизм замещения (`supersede`):

```python
# Получите ID старого решения
old_decisions = memory.search_decisions("FastAPI", mode="audit")
old_id = old_decisions[0]['id']

# Создайте новое решение, которое заменяет старое
memory.supersede_decision(
    title="Миграция на Go (Gin) для веб-слоя",
    target="web_framework",
    rationale="Хотя FastAPI хорошо нам служил, нам нужна модель конкурентности Go "
              "для обработки 10к+ запросов в секунду.",
    old_decision_ids=[old_id]
)
print("Политика обновлена!")
```

## 4. Разрешение истины

Система автоматически приоритизирует актуальные данные. Если вы выполните поиск
сейчас, Ledgermind вернет активное решение на Go, даже если запрос содержит
упоминание «FastAPI».

Это происходит благодаря механизму рекурсивного разрешения истины:

```python
# Система знает, что решение по FastAPI было замещено
results = memory.search_decisions("веб-фреймворк FastAPI", mode="balanced")
print(f"Топ результат: {results[0]['title']} (Статус: {results[0]['status']})")
# Вывод: Топ результат: Миграция на Go (Gin) для веб-слоя (Статус: active)
```

## 5. Аудит через Git

Каждая операция, описанная выше, создает автоматический коммит в `Git`. Вы
можете проверить историю изменений в директории памяти.

Используйте стандартные команды `Git` для просмотра логов:

```bash
cd project_memory
git log --oneline
```

Это гарантирует, что любое изменение в «сознании» агента полностью прозрачно и
может быть проверено человеком.

## Следующие шаги

Вы успешно освоили базовые операции с памятью Ledgermind. Теперь вы можете
интегрировать систему в более сложные сценарии.

- [Руководство по интеграции](../INTEGRATION_GUIDE.md) — узнайте, как настроить
  MCP-сервер.
- [Архитектура](../../README.md#архитектура) — изучите внутреннее устройство
  модулей.
